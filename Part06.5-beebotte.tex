\cleardoublepage

\lgf{\chapter{Séries temporelles}}
\lge{\chapter{Time series}}


\begin{wrapfigure}{r}{3cm}
\Youtube{https://youtu.be/xrdCY4iN40s}
\end{wrapfigure}

\lgf{Les capteurs virtuels que nous avons programmés jusqu’à présent émettent les données à chaque fois que celles-ci sont mesurées. 
Cela permet au serveur de suivre en temps réel le comportement du système étudié. 
Mais dans certains cas, le temps réel n’est pas nécessaire et il est préférable de limiter le nombre d’émissions, par exemple pour économiser l'énergie du capteur.}
\lge{The virtual sensors that we have programmed so far emit data each time they have a measurement. 
This allows the server to follow the behavior of the studied system in real time. 
But in some cases, real time is not necessary and it is preferable to limit the number of emissions, for example to save the energy of the sensor.}

\lgf{Pour ce faire, nous pouvons utiliser un tableau qui va accumuler les valeurs et l’envoyer quand le tableau atteint une certaine taille.}
\lge{To do this, we can use an array that will accumulate the values and send it when the array reaches a certain size.}


\lgf{\section{Envoi d'un tableau}}
\lge{\section{Sending an array}}


\lgf{Le programme \pprog{minimal\_humidity1.py}{plido-tp3} accumule les données dans un tableau \texttt{h\_humidity} quand celui-ci atteint 30 éléments (ligne 17), les données sont envoyées au serveur.}
\lge{The program \pprog{minimal\_humidity1.py}{plido-tp3} accumulates the data in an array \texttt{humidity} when this one reaches 30 elements (line 17), the data are sent to the server.}

\pythonlst{minimal\_humidity1.py}



\begin{termc}[backgroundcolor=\color{palerod}, basicstyle=\ttfamily\small, escapechar=\#]
1 4 [3241]
2 7 [3241, 2945]
3 10 [3241, 2945, 2762]
4 13 [3241, 2945, 2762, 2625]
5 16 [3241, 2945, 2762, 2625, 2480]
6 19 [3241, 2945, 2762, 2625, 2480, 2769]
\end{termc}

\lgf{Le premier chiffre de la ligne indique le nombre d'éléments et le second la taille dans le codage CBOR. On remarque que l'ajout d'un élément augmente la taille du tableau de 3 octets. Les valeurs correspondant à une mesure d'humidité ne varient pas fortement. Ainsi un tableau de 30 mesures a une taille de 92 octets.}
\lge{The first digit of the line indicates the number of elements and the second the size in the CBOR coding. We notice that adding an element increases the size of the array by 3 bytes. The values corresponding to a moisture measurement do not vary greatly. Thus an array of 30 measurements has a size of 92 bytes.}

\lgf{\section{Codage par différence}}
\lge{\section{Differential coding}}

\lgf{On peut optimiser le volume de données transférées en utilisant un codage par delta (i.e. la variation de l'humidité). 
La première valeur du tableau correspond à la valeur mesurée tandis que les suivantes représentent la différence entre la valeur mesurée et la précédente.}
\lge{The amount of data transferred can be optimized by using delta coding (i.e. the variation in humidity). 
The first value in the table is the measured value while the following values represent the difference between the measured value and the previous one.}

\pythonlst[firstline=17,lastline=26,  firstnumber=17]{minimal\_humidity2.py}%[firstline=282,lastline=19, firstnumber=282]

\lgf{Le programme \pprog{minimal\_humidity2.py}{plido-tp3} gère différemment le remplissage du tableau~:}
\lge{The program \pprog{minimal\_humidity2.py}{plido-tp3} handles the filling of the array differently:}

\begin{itemize}
    \item 
        \lgf{ligne 14 et 15, si le tableau est vide, le tableau est créé avec la valeur mesurée,}
        \lge{line 14 and 15, if the table is empty, the table is created with the measured value,}
    \item 
        \lgf{ligne 16 à 22, sinon si le tableau est plein, il est sérialisé en CBOR et envoyé au serveur, puis réinitialisé avec la valeur mesurée,}
        \lge{line 16 to 22, otherwise if the table is full, it is serialized in CBOR and sent to the server, then reset with the measured value,}
    \item 
        \lgf{ligne 23 et 24, sinon la différence entre la précédente valeur et celle mesurée est stockée dans le tableau.}
        \lge{line 23 and 24, otherwise the difference between the previous value and the measured value is stored in the table.}
\end{itemize}

       \vspace{1em}

\lgf{Le listing suivant donne un exemple d'exécution.}
\lge{The following listing gives an example of execution.}


\begin{termc}[backgroundcolor=\color{palerod}, basicstyle=\ttfamily\small, escapechar=\#]
1 4 [2521]
2 6 [2521, 79]
3 8 [2521, 79, 224]
4 10 [2521, 79, 224, -40]
5 12 [2521, 79, 224, -40, -112]
6 13 [2521, 79, 224, -40, -112, 1]
7 15 [2521, 79, 224, -40, -112, 1, 130]
8 18 [2521, 79, 224, -40, -112, 1, 130, -288]
9 21 [2521, 79, 224, -40, -112, 1, 130, -288, 299]
\end{termc}

\lgf{Ceci met en valeur deux souplesses de CBOR~:}
\lge{This highlights two flexibilities of CBOR:}
\begin{itemize}
    \item 
        \lgf{la taille du tableau est dynamique. Si l’on change le nombre de valeurs à transmettre, le tableau l’indique et l’on n’a pas besoin de modifier le code du récepteur~;}
        \lge{the size of the table is dynamic. If the number of values to be transmitted is changed, the array indicates this and there is no need to modify the receiver code;}
    \item 
        \lgf{la taille des données dépend de leur valeur. 
        Pour les variations entre -24 et +23, un seul octet sera nécessaire. 
        On le voit sur l’exemple précédent : l’ajout de la valeur '1' dans le tableau fait passer la taille de la représentation CBOR de 12 à 135 octets. Les valeurs entre 256 et +255 sont transmises sur 2 octets ; il est donc possible de cette manière d’optimiser la transmission sans ajouter de contrainte. S’il y avait une brusque variation de l’humidité, la représentation CBOR s’adapterait pour la transmettre.}
        \lge{the size of the data depends on its value. 
        For variations between -24 and +23, only one byte will be necessary. 
        We can see it on the previous example: the addition of the value '1' in the table increases the size of the CBOR representation from 12 to 135 bytes. The values between 256 and +255 are transmitted on 2 bytes; it is thus possible in this way to optimize the transmission without adding constraints. If there was a sudden change in humidity, the CBOR representation would adapt to transmit it.}
        
\end{itemize}

\lgf{La taille est réduite d"un tiers (environ 66 octets) pour transmettre la même information.}
\lge{The size is reduced by one third (about 66 bytes) to transmit the same information.}

\section{Architecture}

\lgf{La figure~\vref{fig-client-serveur} représente l'architecture générale du système. Le programme \pprog{minimal\_humidity2.py}{plido-tp3} fournit les séries temporelles. Il reste à définir le programme serveur qui va les traiter et faire appel à un autre service pour les afficher sous forme de graphe. }
\lge{Figure~\vref{fig-client-server} represents the general architecture of the system. The program \pprog{minimal_humidity2.py}{plido-tp3} provides the time series. It remains to define the server program which will process them and call another service to display them in the form of a graph. }


       \vspace{1em}


\lgf{Si l'on suit le flux d'information, le capteur va produire des données au format CBOR pour être compact et le programme serveur va transformer cette information en une structure JSON respectant les spécifications du service d'affichage.}
\lge{If we follow the information flow, the sensor will produce data in CBOR format to be compacted and the server program will transform this information into a JSON structure respecting the specifications of the display service.}

\begin{figure}[tbp]
\centerline{\includegraphics[width=1\columnwidth]{Pictures/Capture40.png}}
\lgf{\caption{Architecture Client/Serveur}}
\lge{\caption{Client/Server Architecture}}
\label{fig-client-serveur}
\end{figure}

\section{\Index{Beebotte}}

\lgf{Il existe plusieurs sites qui permettent de le faire. Nous allons utiliser \url{https://beebotte.com}, mais ce que nous allons présenter peut très bien s'appliquer à d'autres sites.}
\lge{There are several sites that allow you to do this. We are going to use \url{https://beebotte.com}, but what we are going to present can very well be applied to other sites.}

\subsection{Configuration}

\begin{wrapfigure}{r}{3cm}
\includegraphics[width=.2\columnwidth]{Pictures/beebotte.png}
\end{wrapfigure}

\lgf{La première étape consiste à créer un compte en cliquant sur \textit{Sign Up} sur la page de garde et en remplissant un formulaire classique avec votre login, adresse de courrier électronique et mot de passe. Une fois le compte validé, le service est accessible.}
\lge{The first step is to create an account by clicking on \textit{Sign Up} on the front page and filling out a standard form with your login, email address and password. Once the account is validated, the service is accessible.}


\lgf{Le compte nous permet de nous authentifier pour gérer les données sur le site, mais il faut également disposer d’autorisation pour pouvoir y déposer des données via l’\Index{API REST}.
Pour cela, il faut se rendre sur la page \textit{Account Setting} puis l’onglet \textit{Access Management}. 
Cette page (cf. figure~\vref{fig-bb-key}) donne une clé et un secret pour gérer l’ensemble des données sur le site. }
\lge{The account allows us to authenticate ourselves to manage the data on the site, but we also need to have authorization to be able to deposit data via the \Index{API REST}.
To do this, you must go to the \textit{Account Setting} page and then the \textit{Access Management} tab. 
This page (see figure~\vref{fig-bb-key}) gives a key and a secret to manage all the data on the site. }


\begin{figure}[tbp]
\centerline{\includegraphics[width=1\columnwidth]{Pictures/bb_root_token.png}}
\lgf{\caption{Clé et secret pour l'authentification}}
\lge{\caption{Key and secret for authentication}}
\label{fig-bb-key}
\end{figure}

\lgf{Notez ces valeurs et stockez les dans un fichier \pprog{config\_bbt.py}{plido-tp3} qui a cet aspect (vos valeurs sont forcément différentes)~:}
\lge{Note these values and store them in a file called \pprog{config\_bbt.py}{plido-tp3} that looks like this (your values are bound to be different):}

\pythonlst{config\_bbt.py}

\lgf{Nous allons maintenant créer un canal (\textit{channel}) dans lequel nous allons définir les objets correspondant aux capteurs. En Cliquant sur \textit {Channels} puis \textit{Create New}, la page représentée figure~\vref{fig-new-channel} apparaît. }
\lge{We are now going to create a channel (\textit{channel}) in which we will define the objects corresponding to the sensors. By clicking on \textit{Channels} and then \textit{Create New}, the page shown in figure~ref{fig-new-channel} appears. }

\lgf{Il faut donner un nom au channel (\textit{capteurs} dans l'exemple), cocher la case \textit{public} et créer trois ressources pour les trois valeurs qui nous intéressent (\textit{temperature}, \textit{humidity}, \textit{presure}) et faire correspondre les unités.}
\lge{You have to give a name to the channel (\textit{sensors} in the example), check the \textit{public} box and create three resources for the three values we are interested in (\textit{temperature}, \textit{humidity}, \textit{presure}) and match the units.}

\lgf{\subsection{Enregistrement des ressources}}
\lge{\subsection{Resource registration}}

\lgf{Le programme \pprog{display\_server.py}{plido-tp3} permet de correspondre avec Beebotte via son API REST. Il commence par l'importation des modules nécessaires~:}
\lge{The program \pprog{display\_server.py}{plido-tp3} allows to correspond with Beebotte via its REST API. It starts by importing the necessary modules:}



\pythonlst[firstline=1,lastline=8, firstnumber=1]{display\_server.py}


\begin{itemize}
    \item 
        \lgf{ligne 4, le module Python \texttt{beebotte}  est disponible pour simplifier la manipulation des données\footnote{S'il n'était pas présent sur votre ordinateur, vous devriez l'installer avec la commande \texttt{pip3 install beebotte}.}.}
        \lge{line 4, the Python module \texttt{beebotte} is available to simplify the manipulation of data\footnote{If it was not present on your computer, you should install it with the command \texttt{pip3 install beebotte}.}.}
    \item 
        \lgf{ligne 5, le module \texttt{contient} la clé et le secret nécessaire à la connexion obtenu précédemment.}
        \lge{line 5, the module \texttt{contains} the key and the secret necessary to the connection obtained previously.}
    
\end{itemize}

\pythonnxt[firstline=9,lastline=11, firstnumber=9]{display\_server.py}

\begin{itemize}
    \item 
        \lgf{ligne 10 et 11 permette d'ouvrir la socket pour communiquer avec les capteurs.}
        \lge{line 10 and 11 allow to open the socket to communicate with the sensors.}
\end{itemize}

\pythonnxt[firstline=12,lastline=14, firstnumber=12]{display\_server.py}

\begin{itemize}
    \item 
        \lgf{ligne 13 une instance permettant la connexion avec les serveurs de Beebotte est définie grâce à la fonction \pfunction{beebotte}{BBT}. Les paramètres de connexion provenant du module \texttt{config\_bbt} sont pris en compte. }
        \lge{line 13 an instance allowing the connection with the Beebotte servers is defined thanks to the function \pfunction{beebotte}{BBT}. The connection parameters from the module \texttt{config\_bbt} are taken into account. }
\end{itemize}

\pythonnxt[firstline=41,lastline=45, firstnumber=41]{display\_server.py}

\lgf{Dans le programme principal, un boucle sans fin attend la série temporelle codée en CBOR venant du capteur (ligne 42), les transforme tableau Python (ligne 44) et appelle la fonction \texttt{to\_btt} en précisant~:}
\lge{In the main program, an endless loop waits for the CBOR coded time series coming from the sensor (line 42), transforms them into a Python array (line 44) and calls the function \texttt{to\_btt} by specifying:}
\begin{itemize}
    \item 
        \lgf{le canal et la ressource qui ont été définie précédemment sur Beebotte~;}
        \lge{the channel and resource that were previously defined on Beebotte;}
    \item 
        \lgf{la série temporelle~;}
        \lge{the time series;}
    \item 
        \lgf{la précision pour transformer ces entiers en flottant.}
        \lge{the precision to transform these integers into floats.}
\end{itemize}

\pythonnxt[firstline=15,lastline=38, firstnumber=15]{display\_server.py}

\lgf{La fonction \texttt{to\_bbt} fait l’essentiel du travail de transformation. Elle prend en argument~:}
\lge{The function \texttt{to\_bbt} does most of the transformation work. It takes as argument:}

\begin{itemize}
    \item 
        \lgf{le nom du canal créé sur Beebotte. Dans notre cas, ce sera \texttt{capteurs}~;}
        \lge{the name of the channel created on Beebotte. In our case, it will be \texttt{sensors};}
    \item  
        \lgf{le nom de l’objet dans ce canal que nous avons également créé sur le site web. Dans notre cas, ce sera \texttt{humidity}~;}
        \lge{the name of the object in this channel that we have also created on the website. In our case, it will be \texttt{humidity};}
    \item  
        \lgf{le tableau Python des mesures codées en delta~;}
        \lge{the Python table of delta-coded measurements;}
    \item  
        \lgf{le facteur multiplicatif, c’est-à-dire la précision. Ici, il faudra diviser par 100~;}
        \lge{the multiplicative factor, i.e. the precision. Here, you will have to divide by 100;}
    \item  
        \lgf{la période entre deux mesures ; cela nous permettra de calculer l’instant de la mesure. Par défaut, la période est de 10 secondes~;}
        \lge{the period between two measurements; this will allow us to calculate the time of the measurement. By default, the period is 10 seconds;}
    \item  
        \lgf{le temps de réception du message pour dater les échantillons. S’il n’est pas spécifié, le temps courant est pris.}
        \lge{the time of reception of the message to date the samples. If it is not specified, the current time is taken.}

\end{itemize}

       \vspace{1em}

\lgf{Cette fonction transforme le tableau Python suivant~:}
\lge{This function transforms the following Python table:}


\begin{termc}[backgroundcolor=\color{palerod},  basicstyle=\ttfamily\small, escapechar=\#]
[3311, 124, -144, -188, -94, 289, -1, -72, 1 ...
\end{termc}
\noindent
\lgf{en un tableau de dictionnaire~:}
\lge{into a dictionary table:}

\begin{termc}[backgroundcolor=\color{palerod},  basicstyle=\ttfamily\small, escapechar=\#]
[{'data': 33.11, 'resource': 'humidity', 'ts': 1596730115000.0},
 {'data': 34.35, 'resource': 'humidity', 'ts': 1596730125000.0},
 {'data': 32.91, 'resource': 'humidity', 'ts': 1596730135000.0},
 {'data': 31.03, 'resource': 'humidity', 'ts': 1596730145000.0},
 ...
\end{termc}

       \vspace{1em}

\lgf{Chaque dictionnaire contient trois éléments imposés par Beebotte :}
\lge{Each dictionary contains three elements imposed by Beebotte:}

\begin{itemize}
    \item 
        \lgf{le nom de la ressource (\texttt{resource}) telle qu'elle a été définie sur l’interface pour le canal~;}
        \lge{the name of the resource (\texttt{resource}) as defined on the interface for the channel;}
    \item 
        \lgf{la valeur associée pour cette ressource (\texttt{data})~;}
        \lge{the associated value for this resource (\texttt{data});}
    \item 
        \lgf{l’instant à laquelle cette mesure a été faite (\texttt{ts}). Le temps est représenté suivant le format \Index{Epoch} qui compte le nombre de secondes depuis le premier Janvier 1970\footnote{voir \url{https://www.epochconverter.com/} pour les conversions.}.}
        \lge{the time at which this measurement was made (\texttt{ts}). The time is represented according to the format \Index{Epoch} which counts the number of seconds since the first of January 1970 \footnote{see \url{https://www.epochconverter.com/} for the conversions}.}
\end{itemize}

       \vspace{1em}

\lgf{Le calcul du \textit{timestamp} (\texttt{ts}) est l’opération la plus complexe de cette fonction mais les module \texttt{time} et \texttt{datetime} facilitent le calcul. 
Si l'argument \texttt{epoch} a été fourni lors de l'appel, la fonction prend cette valeur, sinon le calcule ligne 23. La fonction \pfunction{datetime}{now} retourne la date et l'heure courante, qui est transformé en un tuple grâce à la fonction \pfunction{datetime}{timetuple}. A partir de ce dernier, la fonction \pfunction{time}{maketime} le converti en epoch. }
\lge{The calculation of the \texttit{timestamp} (\texttt{ts}) is the most complex operation of this function but the modules \texttt{time} and \texttt{datetime} facilitate the calculation. 
If the argument \texttt{epoch} has been provided at the time of the call, the function takes this value, otherwise it calculates it on line 23. The function \pfunction{datetime}{now} returns the current date and time, which is transformed into a tuple by the function \pfunction{datetime}{timetuple}. From the latter, the function \pfunction{time}{maketime} converts it into epoch. }

\lgf{Ligne 25, l'epoch à laquelle la première mesure du tableau a été faite est calculé en prenant le temps actuel (cela suppose que l’on néglige le temps de traitement et de transmission) auquel on retranche la durée de la capture, c’est-à-dire comme le nombre d’éléments du tableau multiplié par l’intervalle entre chaque mesure (\texttt{period}). }
\lge{Line 25, the epoch at which the first measurement of the array was made is calculated by taking the current time (this assumes that processing and transmission time are neglected) minus the duration of the capture, i.e. as the number of elements in the array multiplied by the interval between each measurement (\texttt{period}). }

\lgf{Ligne 32 à 34 la structure attendue par Beebotte est construite. le résultat est envoyé, ligne 38, grâce à la fonction \pfunction{beebotte}{writeBulk} qui permet d'envoyer un ensemble de valeurs dans un tableau.}
\lge{Line 32 to 34 the structure expected by Beebotte is built. The result is sent, line 38, thanks to the function \pfunction{beebotte}{writeBulk} which allows to send a set of values in an array.}

       \vspace{1em}

\lgf{On peut vérifier que Beebotte a reçu des données en visualisant le canal capteurs sur l’interface Web. On peut voir sur la  figure~\vref{fig-bb-mesure} que seule la ressource \texttt{humidity} a reçu des données. L’interface affiche la dernière valeur reçue et la date de réception.}
\lge{We can verify that Beebotte has received data by viewing the sensor channel on the web interface. We can see on the figure~\vref{fig-bb-measurement} that only the resource \texttt{humidity} has received data. The interface displays the last value received and the date of reception.}

\begin{figure}[tbp]
\centerline{\includegraphics[width=1\columnwidth]{Pictures/bb_mesures.png}}
\lgf{\caption{État des ressources}}
\lge{\caption{Resource status}}
\label{fig-bb-mesure}
\end{figure}

\lgf{\subsection{Visualisation des ressources}}
\lge{\subsection{Resource visualization}}

\lgf{Maintenant que les ressources sont stockées dans les serveurs de Beebotte, il est possible de les visualiser graphiquement, en allant dans \textit{Dashboard} puis \textit{create Dashboard} et \textit {Add Widget} pour sélectionnez un widget comme \textit{Multi-line chart}.}
\lge{Now that the resources are stored in the Beebotte servers, it is possible to visualize them graphically, by going to \textit{Dashboard} and then \textit{create Dashboard} and \textit{Add Widget} to select a widget such as \textit{Multi-line chart}.}

\lgf{Puis, configurez le widget en définissant le canal et la ressource de ce canal comme le montre la figure~\vref{fig-widget}.}
\lge{Then, configure the widget by setting the channel and the resource for that channel as shown in figure~\vref{fig-widget}.}

\begin{figure}[tbp]
\centerline{\includegraphics[width=0.5\columnwidth]{Pictures/bb_new_widget.png}}
       \vspace{1em}
\centerline{\includegraphics[width=0.5\columnwidth]{Pictures/bb_conf_widget.png}}
\lgf{\caption{Création d'un widget}}
\lge{\caption{Creating a widget}}
\label{fig-widget}
\end{figure}

\lgf{En retournant sur le dashboard, on peut voir l’évolution de l’humidité au cours du temps (cf. figure~\vref{fig-bb-humidity}). }
\lge{By going back to the dashboard, we can see the evolution of the humidity over time (see figure~\vref{fig-bb-humidity}). }

\begin{figure}[tbp]
\centerline{\includegraphics[width=1\columnwidth]{Pictures/bb_humidity.png}}
\lgf{\caption{Suivi de l'humidité}}
\lge{\caption{Humidity monitoring}}
\label{fig-bb-humidity}
\end{figure}

\lgf{\section{Interopérabilité}}
\lge{\section{Interoperability}}

\lgf{La chaîne de collecte de l'information que nous venons de construire allant du capteur à l'affichage, n'est pas complètement interopérable. Certes le capteur envoie des données au format CBOR qui peuvent être interprété par l'autre extrémité, mais le récepteur ne sait pas~:}
\lge{The chain of information collection that we have just built, from the sensor to the display, is not completely interoperable. Certainly the sensor sends data in CBOR format that can be interpreted by the other end, but the receiver does not know:}

\begin{itemize}
    \item 
        \lgf{qu'il s'agit d'une série temporelle codée avec des deltas~;}
        \lgf{that it is a coded time series with deltas;}
    \item  
        \lgf{que les données ont été multipliée par 100 pour pouvoir envoyer des nombres entiers, plus compacts sans perdre trop de précision~;}
        \lgf{that the data have been multiplied by 100 to be able to send whole numbers, more compact without losing too much precision;}
    \item  
        \lgf{que le pas de mesure est de 10 secondes~;}
        \lgf{that the measurement step is 10 seconds;}
    \item  
        \lgf{que les données concernent le taux d'humidité.}
        \lgf{that the data are related to the moisture content.}
\end{itemize}

\lgf{Ces informations ont été précisées dans le programme \pprog{display\_server.py}{plido-tp3}, de même la transformation de la structure de tableau de la série temporelle en un dictionnaire avec des mots clés spécifique à Beebotte on été gravé dans le programme. }
\lge{This information was specified in the program \pprog{display_server.py}{plido-tp3}, as well as the transformation of the table structure of the time series into a dictionary with keywords specific to Beebotte was engraved in the program. }

       \vspace{1em}

\lgf{Nous verrons par la suite comment améliorer cette interopérabilité.}
\lge{We will see later on how to improve this interoperability.}

\lgf{\section{et SenML ?}}
\lge{\section{and SenML?}}

\lgf{Dans la communication avec Beebotte,  le site structure l’envoi des mesures en définissant un dictionnaire JSON avec des mots clés particuliers. Pour utiliser un autre site, le format des échanges doit êter modifié même si les informations restent identiques.}
\lge{In the communication with Beebotte, the site structures the sending of measurements by defining a JSON dictionary with particular keywords. To use another site, the exchange format must be modified even if the information remains identical.}

       \vspace{1em}

\lgf{De plus, lors de la configuration des ressources sur le site de Beebotte, la nature de la mesure a du être précisée~; par exemple, s’il s’agit d’une température, d’un taux d’humidité... Il faut également parfois indiquer le type de la mesure (texte, entier, flottant...) voire les unités. }
\lge{In addition, when configuring the resources on the Beebotte site, the nature of the measurement had to be specified; for example, whether it is a temperature, a humidity level... It is also sometimes necessary to indicate the type of measurement (text, integer, float...) and even the units. }

       \vspace{1em}

\lgf{\ac{SenML} défini dans le \rfc{8428} propose une structuration des données fournie par le capteur. 
Pour réduire l’impact de la transmission, les noms des champs ont été choisis pour être le plus compact possible. 
Par exemple, la lettre \texttt{v}  va indiquer une valeur (à comparer avec la clé \texttt{data} utilisée lors de la communication avec Beebotte). 
Pour être encore plus compact, la représentation en CBOR utilisera des entiers courts au lieu de caractères.}
\lge{\ac{SenML} defined in the \rfc{8428} structures the data provided by the sensor. 
To reduce the impact of the transmission, the field names have been chosen to be as compact as possible. 
For example, the letter \texttt{v} will indicate a value (to be compared with the key \texttt{data} used during the communication with Beebotte). 
To be even more compact, the representation in CBOR will use short integers instead of characters.}

       \vspace{1em}

\lgf{Il est également possible de transporter l’unité de la mesure avec le mot clé \texttt{u} .}
\lge{It is also possible to transport the unit of measurement with the keyword \texttt{u} .}

\lgf{SenML ne définit pas que des unités  du système international, mais également des unités secondaires pour limiter la taille de la représentation. Il sera plus compact de transmettre~:}
\lge{SenML does not only define units of the international system, but also secondary units to limit the size of the representation. It will be more compact to transmit:}

\begin{termc}[backgroundcolor=\color{palerod}, basicstyle=\ttfamily\small, escapechar=\#]
{"u": "MHz", "v": 868}
\end{termc}

\noindent
\lgf{que}
\lge{than}

\begin{termc}[backgroundcolor=\color{palerod},  basicstyle=\ttfamily\small, escapechar=\#]
{"u": Hz", "v": 868000000}.
\end{termc}

\lgf{Le standard définit aussi des temps de base et des valeurs de base auxquelles les temps et les valeurs vont se référer ; ce qui permet également de réduire la taille des valeurs. Finalement, le ou les objets peuvent s’identifier dans les données transmises en définissant un nom de base (\texttt{bn} : \textit{base name}), le nom du capteur (\texttt{n} : \textit{name}) vient compléter le nom de base.}
\lge{The standard also defines base times and base values to which the times and values will refer; this also makes it possible to reduce the size of the values. Finally, the object(s) can be identified in the transmitted data by defining a base name (\texttt{bn} : \textit{base name}), the name of the sensor (\texttt{n} : \textit{name}) completes the base name.}

\lgf{\subsubsection{Émission}}
\lge{\subsubsection{Sending}}

\pythonlst{minimal\_senml\_client.py}

\lgf{Le programme \pprog{minimal\_senml\_client.py}{plido-tp3} illustre le fonctionnement de SenML. Il repose sur deux objets~:}
\lge{The program \pprog{minimal_senml\_client.py}{plido-tp3} illustrates how SenML works. It is based on two objects:}

\begin{itemize}
    \item
        \lgf{l'objet \pfunction{kpn\_senml}{SenmlPack} inclus les informations commune à l'objet, comme le nom de base (ici \texttt{device1} ligne 23) ou la base de temps, ligne 24.}
        \lge{the object \pfunction{kpn\_senml}{SenmlPack} includes information common to the object, such as the base name (here \texttt{device1} line 23) or the time base, line 24.}
    \item 
        \lgf{l'objet \pfunction{kpn\_senml}{SenmlRecord} contient une mesure où l'on peut préciser son nom, son unité et sa valeur (lignes 32, 38 et 43). Le temps est également précisé ligne 35. Ces enregistrements sont ajoutés à l'objet \texttt{pack}.}
        \lge{the object \pfunction{kpn\_senml}{SenmlRecord} contains a measure where we can specify its name, its unit and its value (lines 32, 38 and 43). The time is also specified on line 35. These records are added to the object \texttt{pack}.}
\end{itemize}

\lgf{Le programme récupère les trois valeurs de température, humidité et pression (lignes 27 à 29) en les arrondissant à 2 chiffres après la virgule pour la température et l'humidité et converti la pression, d'hecto Pascal en Pascal puisque c'est l'unité définie par SenML. }
\lge{The program retrieves the three values of temperature, humidity and pressure (lines 27 to 29) by rounding them to 2 digits after the decimal point for temperature and humidity and converts the pressure from hecto Pascal to Pascal since this is the unit defined by SenML. }

\lgf{Les mesures se font toutes les 10 seconde (délais ligne 48) et quand le nombre de mesures défini ligne 13 est atteint, le codage SenML en CBOR est envoyé au serveur. }
\lge{Measurements are made every 10 seconds (delays line 48) and when the number of measurements defined on line 13 is reached, the SenML coding in CBOR is sent to the server. }

       \vspace{1em}

\begin{termc}[backgroundcolor=\color{palerod}, basicstyle=\ttfamily\small, escapechar=\#]
[{'bn': 'device1', 'bt': 1640110457.0,  
  'n': 'temperature', 't': 0.0, 'u': 'Cel',   'v': 19.98},
 {'n': 'humidity', 'u': '%RH', 'v': 28.46},
 {'n': 'pressure', 'u': 'Pa', 'v': 100093}]
JSON length:  177 bytes
CBOR length:  104 bytes
\end{termc}

\lgf{Ce premier listing montre le premier enregistrement pour les trois grandeurs mesurées. Il s'agit d'un tableau de 3 éléments. Le premier contient les valeurs de bases (ici le nom et l'heure de référence) suivi de la grandeur à mesurer, de son unité et sa valeur. Le deuxième et le troisième éléments, mettent à jours le nom de la grandeur, son unité et sa valeur, les autres informations précédemment définies restent valables.}
\lge{This first listing shows the first record for the three measured quantities. It is a table of 3 elements. The first contains the basic values (here the name and the reference time) followed by the quantity to be measured, its unit and its value. The second and third elements update the name of the quantity, its unit and its value, the other information previously defined remains valid.}


\begin{termc}[backgroundcolor=\color{palerod},  basicstyle=\ttfamily\small, escapechar=@]
[@\textcolor{gray}{\{'bn': 'device1',  'bt': 1640110457.0,}@
 @\textcolor{gray}{ 'n': 'temperature',  't': 0.0, 'u': 'Cel', 'v': 19.98\},}@
 @\textcolor{gray}{\{'n': 'humidity', 'u': '\%RH', 'v': 28.46\},}@
 @\textcolor{gray}{\{'n': 'pressure', 'u': 'Pa', 'v': 100093\},}@
 {'n': 'temperature', 't': 10.0, 'u': 'Cel', 'v': 20.03},
 {'n': 'humidity', 'u': '%RH', 'v': 26.86},
 {'n': 'pressure', 'u': 'Pa', 'v': 100065}]
JSON length:  318 bytes
CBOR length:  188 bytes
 \end{termc}
 
 \lgf{Quand on ajoute 10 secondes plus tard de nouvelles mesures,  un temps relatif de 10 secondes est indiqué pour l'enregistrement des températures et il reste valable pour les enregistrements suivants.}
 \lge{When new measurements are added 10 seconds later, a relative time of 10 seconds is indicated for the temperature recording and it remains valid for the following recordings.}
 
 
 \Question{codage}
 {A quoi correspond la clé \texttt{'u' : 'Cel'} que l'on retrouve dans la structure précédente ? }
 {Unité = degrés Celcius}
 
 \Question{Accroissement}
 {Dans les deux représentations JSON et CBOR, de combien la taille est-elle accrue par l'ajout des mesures effectuées ? d'où viennent ces différences ?}
 {
 Si l'on regarde le listing précédent, l'ajout des trois mesures fait augmenter la taille de 141 octets pour JSON et 84 pour CBOR. La différence vient de l'utilisation de nombre plus que de chaînes de caractères pour les clés. Ainsi 't' demande 3 caractères en JSON avec les guillemets, codé en CBOR, il faudrait 2 octets, un nombre inférieur à 23 se code sur un seul octet. Il y a egalement les virgules, espaces et fermeture de crochets qui ne sont pas présent en CBOR. Les nombres flottant comme \texttt{19.98} ont une représentation plus compacte en JSON (5 octets) qu'en CBOR où ils consomment 9 octets. Dans tous les cas l'accroissement est fortement dépendant du nom des éléments. Ici, il faut répéter à chaque fois \texttt{temperature}, \texttt{humidity} et \texttt{pressure}, soit 26 caractères.
 }
 
 \Question {Une seule grandeur}
 {Si on ne s'intéressait qu'à une seule grandeur, par exemple l'humidité. A quoi ressemblerait la structure SenML en JSON ?}
 {
 Chaque nouvelle entrée ajoute 35 octets à la structure~: 
 [\{'bn': 'device1',  'bt': 1640110457.0, 'n': 'humidty', 'u': '\%RH', 'v': 28.46\},\\
 \{'t': 10.0, 'v': 26.86\},\\
 \{'t': 20.0, 'v': 26.96\},\\
 \{'t': 30.0, 'v': 27.01\}]\\
 }
 
 \subsubsection{Réception}
 
 Le traitement par le module SenML tel qu'il est mis en œuvre n'est pas complet, il ne gère pas correctement les timestamps. Mais, il n'est pas vraiment nécessaire pour traiter ces messages. En effet, comme on l'a vu précédemment, les objets SenML sont cumulatifs, une clé reste présente dans les enregistrements suivants sauf si elle est redéfinie. 
 
 
 \pythonlst{minimal\_senml\_server.py}
 
 Le programme \pprog{minimal\_senml\_server.py}{plido-tp3} va convertir le format SenML codé en CBOR dans le format attendu par Beebotte. 
 La version CBOR utilise ds nombres plutôt que des tags.
 Le dictionnaire \texttt{naming\_map} defini lignes 10 à 12 permet la correspondance utilisé par la suite pour rendre le code plus lisible.
 
 Les lignes 14 à 17 initialisent les communications venant du capteur et celles allant à Beebotte. 
 
 Les données reçues ligne 21 sont transformée en structure Python ligne 23. Cette correspondance est possible car Python autorise des clés numériques et celles-ci ne sont pas répétées plusieurs fois dans une map CBOR.
 
La boucle commençant ligne 28 permet d'explorer tous les éléments du tableau SenML, les nouvelles entrées sont fusionnées avec les anciennes (ligne 29)\footnote{Dans les version plus récentes de Python, il est possible d'utiliser l'opérateur \texttt{|}.}. 

Les informations concernant le temps sont ensuite recherchées. 
D'abord le temps (ligne 32) et s'il un temps de base existe (ligne 33) il est ajouté. On procède de même pour la valeur (lignes 38 à 40). Pour le nom, il n'y a pas de concaténation car le nom de base sera utilisé comme canal Beebotte, il est récupéré à la fin ligne 46.

A partir de ces informations, la structure attendue par Beebotte est construite ligne 43 en ajoutant le dictionnaire dans le tableau \texttt{bbt\_record}.

Ligne 47, l'information est envoyée à Beebotte. Si les clés d'authentification, le nom du canal et des ressources sont correct, les information s'affiche sur le site, comme précédemment. 

\begin{termc}[backgroundcolor=\color{palerod},  basicstyle=\ttfamily\tiny, escapechar=@]
{0: 'temperature', 1: 'Cel', 2: 19.44, 6: 0.0, -3: 1640168049.0, -2: 'device1'}
{0: 'humidity', 1: '%RH', 2: 24.13, 6: 0.0, -3: 1640168049.0, -2: 'device1'}
{0: 'pressure', 1: 'Pa', 2: 101080, 6: 0.0, -3: 1640168049.0, -2: 'device1'}
{0: 'temperature', 1: 'Cel', 2: 19.48, 6: 10.0, -3: 1640168049.0, -2: 'device1'}
{0: 'humidity', 1: '%RH', 2: 21.85, 6: 10.0, -3: 1640168049.0, -2: 'device1'}
{0: 'pressure', 1: 'Pa', 2: 101090, 6: 10.0, -3: 1640168049.0, -2: 'device1'}
{0: 'temperature', 1: 'Cel', 2: 19.57, 6: 20.0, -3: 1640168049.0, -2: 'device1'}
{0: 'humidity', 1: '%RH', 2: 21.09, 6: 20.0, -3: 1640168049.0, -2: 'device1'}
{0: 'pressure', 1: 'Pa', 2: 101058, 6: 20.0, -3: 1640168049.0, -2: 'device1'}
{0: 'temperature', 1: 'Cel', 2: 19.52, 6: 30.0, -3: 1640168049.0, -2: 'device1'}
{0: 'humidity', 1: '%RH', 2: 20.39, 6: 30.0, -3: 1640168049.0, -2: 'device1'}
{0: 'pressure', 1: 'Pa', 2: 101120, 6: 30.0, -3: 1640168049.0, -2: 'device1'}
{0: 'temperature', 1: 'Cel', 2: 19.44, 6: 40.0, -3: 1640168049.0, -2: 'device1'}
{0: 'humidity', 1: '%RH', 2: 21.94, 6: 40.0, -3: 1640168049.0, -2: 'device1'}
{0: 'pressure', 1: 'Pa', 2: 101128, 6: 40.0, -3: 1640168049.0, -2: 'device1'}
[{'data': 19.44, 'resource': 'temperature', 'ts': 1640168049000.0},
 {'data': 24.13, 'resource': 'humidity', 'ts': 1640168049000.0},
 {'data': 101080, 'resource': 'pressure', 'ts': 1640168049000.0},
 {'data': 19.48, 'resource': 'temperature', 'ts': 1640168059000.0},
 {'data': 21.85, 'resource': 'humidity', 'ts': 1640168059000.0},
 {'data': 101090, 'resource': 'pressure', 'ts': 1640168059000.0},
 {'data': 19.57, 'resource': 'temperature', 'ts': 1640168069000.0},
 {'data': 21.09, 'resource': 'humidity', 'ts': 1640168069000.0},
 {'data': 101058, 'resource': 'pressure', 'ts': 1640168069000.0},
 {'data': 19.52, 'resource': 'temperature', 'ts': 1640168079000.0},
 {'data': 20.39, 'resource': 'humidity', 'ts': 1640168079000.0},
 {'data': 101120, 'resource': 'pressure', 'ts': 1640168079000.0},
 {'data': 19.44, 'resource': 'temperature', 'ts': 1640168089000.0},
 {'data': 21.94, 'resource': 'humidity', 'ts': 1640168089000.0},
 {'data': 101128, 'resource': 'pressure', 'ts': 1640168089000.0}]
 \end{termc}
 
 Le listing précédent montre cette transformation.
 Les premières lignes correspondent aux enregistrements fusionnées et le tableau final, ce qui a été envoyé à Beebotte.
 
 \Question{base value}
 {
 Pourrait-on utiliser le champ SenML \textit{base value} pour diminuer la taille des données de pression atmosphérique~?
 }
 {
Cela serait possible, si cette ressource était envoyée seule.
 }